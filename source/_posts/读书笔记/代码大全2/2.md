---
layout: default
title: 代码大全 2 -- 读书笔记二
categories:
  - 读书笔记
  - 代码大全2
---

<a name="ae6e49b4"></a>

## [](#变量)变量

不允许隐式声明。在声明的时候初始化。

我们要将变量引用局部化，尽量缩小变量的使用范围。那些介于同一变量多个引用点之间的代码可称为“攻击窗口”。如果引用点之间非常远，阅读者的目光需要在程序里面跳来跳去。变量的引用点集中起来的主要好处是为了提高程序的可读性。

可读性是写代码最重要的事情！

与变量跨度相同的一个概念是“存活时间”，即开始于他的第一次引用，结束于最后一次引用，要保持较低的存活时间。尤其是当我们需要把一个大的子程序拆成多个小的子程序的时候，短的变量存活时间很有价值。

用跨度和存活时间来考察全局变量，就会发现全局变量的跨度和存活时间都很长，这也是避免使用全局变量的原因之一。

<a name="c4010839"></a>

#### [](#变量可见范围的原则)变量可见范围的原则

我们要在最开始采用最严格的可见性，然后根据需要扩展变量的作用域。缩减一个很大作用域的变量的作用域是非常困难的。

<a name="313fb48a"></a>

#### [](#为什么缩小变量作用域)为什么缩小变量作用域

取决于我们如何管理“方便性”和“智力上的可管理性”。变量越局部化，你能够隐藏的信息越多，在同一时间需要考虑的信息就越少。

归根揭底的问题是你选择写程序还是读程序？作用域最大化固然方便，但是一旦作用域方法，你就没法去单独理解某个子程序，你就还得去理解其他使用了数据的子程序。

<a name="323bd2e1"></a>

#### [](#灵活性)灵活性

书从一个例子来看待灵活性和复杂度的问题：<br />绑定时间的问题，我们写 a = '#f00'，这就是编码时绑定;我们写 a = COLOR.RED，定义一个具名常量，就是编译时绑定。同理绑定方式有如下的情况：

- 编码时

- 编译时

- 加载时

- 实例时

- 即时

越往下灵活性越强，但是与之对应的，支持这种灵活性的代码也就复杂度会越高。我们要按照需要选择足够的灵活性来满足软件需求。

灵活性与软件的复杂度成反比，选择适合的灵活性才是我们应该做的！

<a name="a5f4c22d"></a>

#### [](#混合耦合)混合耦合

我们要让每个变量只有单一用途。避免让代码具有隐含含义。

比如 pageCount 等于已经打印的纸张的数量，除非他等于-1。这代表了出错。

这种情况就是“混合耦合”！！pageCount 这种整数类型客串了布尔类型！！

貌似自己应该使用“混合耦合”，比较明显的就是之前我们定义的 format 为 null，空字符串，undefined！！以后一定要注意，这样子的代价很大！

<a name="11386f27"></a>

## [](#变量名)变量名

变量名必须反映问题本身，而不是反映计算的某些方面！

比如一条员工数据记录可能会被翻译成 inputRec 或者 employeeData， inputRec 其实就是一个计算机思维的术语，而 employeeData 才是直指问题领域。

这个问题也是很容易犯的，毕竟程序员思维根深蒂固。

并不一定短的变量名就是不好的，比如 i 这样的变量名其实就暗示了这只是个临时数据，作用域非常有限。较长的名字适合很少用到或者全局变量，要根据情况选择。

使用肯定的布尔变量名，notFound，notDone 这种取反之后太难理解！

<a name="d01ed6a0"></a>

#### [](#定规则的好处)定规则的好处

程序员内心抵制规则，不过好的规则还是很重要。命名规则的好处：

- 通过做一个全局决策而不是很多局部决策，让你集中精力关注代码更重要的地方

- 有助于项目之间传递知识。名字的相似性让你更容易理解那些不熟悉的变量

- 有助于减少名字增生

比较典型的就是我定义的 hideHeader 和翎一定义的 noHeader，做了同一件事情，名字却不一样。

规则的存在为你的代码增加了结构，减少了你需要考虑的事情。

<a name="7232c4e7"></a>

## [](#条件语句)条件语句

我们要把正常情况的处理放在 if 后面而不是 else 后面，为了更好的可读性。

把最常见的情况放在前面。

<a name="df242770"></a>

## [](#循环控制)循环控制

我们要把循环体执行的条件表述清楚，不要让读者看了循环体之后才知道循环的控制，要把他做成黑盒子。外围程序只知道他的控制条件，而不是他的内容。

一次循环尽量只做一件事。循环可以同时做两件事这个事实并不能证明这两件事是应该放在一起的。每个循环只做一件并把它做好。性能在真的遇到问题的时候再优化。

在用递归之间，必须明白，你用堆和栈一样可以做到。在决定用之前，请都尝试一下。

<a name="fe40f98b"></a>

## [](#查询表)查询表

查询表平常很经常使用，消除 if else 的绝佳方法。

当逻辑足够复杂，你又无法使用继承和多态来解决，又不想写个复杂的 if else 的时候，建立一个强大的查询表吧。

之前做 portal 需要根据状态来绘制下面这个图，根据应用上线的状态以及开通状态来绘制。包括显示几个按钮，是否显示角标，显示什么颜色的图像，显示什么提示，显示什么状态:

![](https://cdn.yuque.com/lark/2018/png/b6883221-98ab-40a6-a994-c34f25f3c440.png#width=593)
原来最后自己的实现方式就是建立一个查询表，放上自己的实现，有好的思路欢迎讨论:

![](https://cdn.yuque.com/lark/2018/png/20c539c7-2c97-4a4b-88a5-0fed85dc888a.png#width=547)
如果键值不太好设置的话，可以用一个专门的子程序来计算键值。

文章里写的阶梯访问表以及用二分法来优化阶梯访问表挺不错的，我就不细写了。
