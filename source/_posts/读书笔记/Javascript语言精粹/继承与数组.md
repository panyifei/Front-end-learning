---
layout: default
title: js语言精粹-继承与数组
categories:
  - 读书笔记
  - js语言精粹
---

## 继承

### 伪类

就是很简单的原型继承，唯一需要注意的就是调用构造函数的时候我们需要使用 new，如果不用的话，就会直接把属性挂载到 window 上了。

我们可以在里面加入检测，参见上一篇文章。

### 对象说明符

就是说我们在传入多个参数的时候，建议直接传入一个对象，因为这样，我们就可以在调用的时候写的比较清楚。

### 函数化

到目前为止的继承都没有办法实现私有的模式，我们可以应用模块模式来创建私有的成员。

```javascript
var build = function(obj) {
  var name = "1214";
  obj.get_name = function() {
    return name;
  };
  return obj;
};
```

这样子我们唯一访问 name 的途径就是通过 build({}).get_name();我们可以将这个东西彻底私有。

### 部件

上面的写法就是一种扩展部件的形式，我们可以在任意对象上调用 build 方法，来对这个对象进行新功能的封装，并且拥有者一些私有的方法。

## 数组

JS 本身其实没有数组的数据结构，但是他有一个 array-like 的对象。与其他语言相比，他不要求里面的对象类型相同。和一般的对象相比，他多了能够使用序号访问属性的能力，而且还有一个无法遍历的属性 length。

length 属性的值是数组的最大整数属性名加 1。

将 length 的值设置小，超出的部分将会被截掉，设置大了，会填充 undefined。

我们使用 delete 可以删除数组中的元素，但是会留下一个空洞 undefined。

我们想要优雅的删除，可以使用 slice，从某一个位置截到另一个位置，如果只有一个参数，就截到最后，如果是负数，就加上 length 后再看。或者使用比较强大的 splice 方法，一参为位置，2 参为数量，后面的为想要添加的元素。

这几个函数每次操作都会移除原属性，重新插入，所以大型数组的效率不会太好。换种数据结构呗..链表不就完了

### 枚举

for in 倒是可以遍历，但是无法保证属性的顺序，可能有些浏览器是按照顺序来的，但是我们没法保证。而且从原型继承来的属性问题依然存在，倒是可以 Object.hasOwnProperty 来判断，不过太麻烦了。一般就直接用 for 语句了。

### 判断 array

我们可以 typeof 属性 length 看是不是 number，然后 propertyIsEnumerable 来检测 length 是不是无法枚举。

或者 Object.prototype.toString().apply(value) == '[object Array]'来判断。
