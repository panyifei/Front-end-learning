---
layout: default
title: \{#\{ site.name \}#\}
---
# 3章创建型模式
创建型模式抽象了实例化过程。帮助系统独立于如何创建，组合和表示他的那些个对象。类创建模式使用继承改变被实例化的类。而对象创建型模式将实例化的操作托付给另一个对象。

随着系统演化得越来越依赖于对象符合而不是类继承。系统使用那些具体的类被封装了。隐藏了这些类的实例是如何被创建和放在一起的。创建型模式什么时候被创建，谁创建，以及怎样被创建都是有自主性的。

有时创建型模式是相互竞争的，也有时候他们是可以互补的。

书里先是举了个创建一个迷宫的例子，就是调用了构造方法。然后使用它的实例来进行各种东西的初始化。

虽然我们可以在构造函数中来提前初始化每一面。(这个目前我认为已经解决了问题了...)但是这样仅仅是把代码移到了别的地方，这样子代码会更小，但是设计没有更灵活。我们一旦改变了布局就得重新写一个构造函数。

 - 一种是调用虚函数而不是构造器来创建。我们就可以创建子类并且重定义虚函数。从而改变被例化的类。这是Factory Method模式的一个例子。
 - 通过传入对象来作为参数，可以通过传入不同的参数来改变房间，墙壁和门的类，这是抽象工厂的模式
 - 通过传递一个对象，这个对象可以在迷宫中增加或者减少门房间，墙壁和门。这就是建造者模式的一个例子。
 - 如果由多种原型的房间，墙壁和门对象参数化，可以用不同的对象替换这些原型对象以改变迷宫的构成。这就是Prototype的例子。
 - Singleton保证了每个游戏只有一个迷宫且所有的游戏对象都可以迅速访问它。

 ## 抽象工厂模式--对象创建型模式
 意图：提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。产品种类是固定的，产品系列可以被替换~想增加产品种类会比较麻烦，因为所有工厂都必须改。

 就是定义了一个抽象类，这个类定义了一些接口，然后每种想创建的都是具体的子类来实现具体的功能，然后用户们完全根据`抽象类提供的接口`来使用。客户完全不知道他们使用的是哪些具体类。

适用性：

 - 一个系统要独立于他的产品的创建，组合和表示的时候
 - 系统要由多个产品系列的一个来配置
 - 强调一系列产品对象的设计以便联合使用
 - 提供一个产品类库，只想显示他们的接口而不是他们的实现时

优缺点：

 - 分离了具体的类：将客户与类的实现分离，客户通过他们的抽象接口操纵实例。
 - 使得易于交换产品系列：具体工厂只在初始化的时候，于是我们可以很方便的改变应用的具体工厂
 - 有利于产品的一致性：当系列中产品对象被设计成一起工作的时候，他能保证一次只能使用同一个系列的对象
 - 不能支持新种类的产品：就是抽象工厂如果被扩展的话，会影响到所有的实现。

我们使用工厂的时候，可以通过传递一个参数来指示要创建的对象的种类的参数。

## BUILDER(生成器)--对象创建型模式
意图：将一个复杂对象的构建和他的表示分离，使同样的构建过程可以创建不同的表示。不变的是构建步骤，构建的具体操作可以被多种替换~

就是用户使用一个director来根据一定的步骤来调用builder的创建方法，然后用户从builder那里得到最后生成的东西。(之所以不从director拿是因为director里面不知道生产的是什么产品，只有builder和用户才知道产品是什么)  

适用性：

 - 当创建复杂对象的算法应该独立于对象的组成方式以及装配方式
 - 构造过程必须允许被构造的对象有不同的表示时

效果：

 - 可以改变一个产品的内部表示：因为提供给导向器的是一个抽象接口，所以产品的表示和内在结构其实是被隐藏的
 - 将构造代码和表示代码分开：就是代码拆离开了，用户可以使用不同的director来在相同构件的基础上构做不同的product
 - 可以使得构造过程更精细的控制：因为是在导向者的控制下进行合成，所以builder的接口会很好的反映产品的构造过程

这里说抽象工厂和建造者模式的区别是：builder是一步步构造复杂对象，抽象工厂着重于多个系列的产品对象，抽象工厂直接拿到产品，builder最后拿到。

## 工厂方法--对象创建型模式
意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到他的子类。选择使用哪个工厂的事情交给了使用者。每一个新的产品都得新增一个工厂。

适用性：

 - 当一个类不知道它所必须创建的对象的类的时候
 - 当一个类希望由他的子类来指定它所创建的对象的时候
 - 当类将创建对象的职责委托给多个帮助子类中的某一个

 效果：

  - 代码仅处理product接口，可以与用户定义的任何ConcreateProduct类一起使用
  - 每一个产品都需要创建一个工厂
  - 工厂方法创建比直接创建一个对象更灵活，他给了子类一个挂钩，可以提供对象的扩展版本。
  - 连接平行的类层次，将信息局部化了，保持类的平行。

书里没有介绍简单工厂，就是只有一个创建的工厂，通过传入的参数的不同来创造出不同的产品，坏处是要增加新产品的时候得修改原有的工厂，违反了开放封闭原则。

## PROTOTYPE(原型) --对象创建型模式
意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

效果：

 - 对于用户隐藏了具体的产品类
 - 减少了子类的构造，省去了creator这种东西。

缺点：每个类都得实现一个clone借口

这个模式主要是GUI时代的产物，那个时候需要的就会复制一个东西，而现在这种需求很少了。前端就更少了，前端没有类的概念，复制一个对象的成本很小。

## SINGLETON(单件) --对象创建型模式
意图：保证一个类只有一个实例，并且提供一个访问它的全局访问点

适用性：当类只能有一个实例并且客户可以从一个众所周知的访问点访问它的时候，类负责保存唯一实例，并且通过截取住创造函数的方式来截取住

效果：

 - 对唯一实例的受控访问
 - 缩小命名空间
 - 允许对操作和表示的精化
 - 允许可变数目的实例
 - 比类操作更灵活
