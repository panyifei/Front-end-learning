## IIFE

就是立即调用函数表达式，主要目的是在 ES5 时期创建一个 scope，而且不存在指向他的引用，执行完就被回收了。

## 如何处理中文输入

其实很简单，就是 input 的 compositionStart，compositionUpdate，compositionEnd 这三个方法

## 浮点数相加减

就是记住.的位置，然后转化成整数来算，然后补上.的位置就好了

## class 写法与直接 function 的区别

- class 会提升
- class 内部是严格模式
- 只能 new 调用
- 所有方法不可枚举
- 内部方法没有 constructor，不可 new
- class 内部不能重写类名

## 鉴别数组

arr instanceOf Array // 判断原型链，不能区分 iframe
Object.prototype.toString().call(arr) === '[object Type]' // toString 方法不能被重写
Object.isArray(arr) // ES5 才有

## 箭头函数与普通函数

- 函数内的 this，是定义时的，而不是使用时的
- 没有 arguments 对象
- 不可以 new，因为没有 this，没有 prototype
- 不可以使用 yield 命令

## onload 和 domcontentloaded 事件

- domcontentloaded 是在 dom 树构建好了触发，不会等待 img，外联样式以及 async，defer 的加载。
- onload 是所有的资源都加载好了才会触发

## 树比较的算法

两个树的节点一一比较，是 n 的平方
再查找怎么变换的，还需要 n，所以总共是 n 的 3 次方。

react 通过了一些手段变成了接近 n。

## react-redux 实现

就是提供了一个 provider，挂在最外面一层的组件上。然后再提供一个 connect 来拿取数据以及 action。
connect 实现很简单，就是 store.subscribe 监听，然后重新 setState 就行了。

## reac 为什么要加 key

因为如果有 key 的话，他可以直接比对属性，属性有变化就更新，否则不更新。没有 key，就会销毁然后重新创建。

只报 warning 是因为他会默认按照 index 作为 key，问题就是只变化了属性了，但是比如 input 这种有自己的 vaue 的，就不会同步，就会错乱了。

## 宏任务的渲染

就是浏览器会执行完当前宏任务，然后执行掉全部的微任务，然后渲染一次，就是一帧。

## Array.isArray 和 instanceof

Array.isArray 能够检查 iframe 上的 array。

## redux 中间件

app.middleware.reduceRight((a,b) => () => b(a), () => {})
然后中间件里面调用 next 就会触发下一轮中间件，然后执行完了之后还能有一些处理

## 数组判断 NaN

includes 方法可以判断
