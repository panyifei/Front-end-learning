---
layout: default
title: \{#\{ site.name \}#\}
---
# 继承与数组
## 继承
### 伪类
就是很简单的原型继承，唯一需要注意的就是调用构造函数的时候我们需要使用new，如果不用的话，就会直接把属性挂载到window上了。

我们可以在里面加入检测，参见上一篇文章。

### 对象说明符
就是说我们在传入多个参数的时候，建议直接传入一个对象，因为这样，我们就可以在调用的时候写的比较清楚。

### 函数化
到目前为止的继承都没有办法实现私有的模式，我们可以应用模块模式来创建私有的成员。

```javascript
var build = function(obj){
  var name = '1214';
  obj.get_name = function(){
      return name;
  }
  return obj;
}
```

这样子我们唯一访问name的途径就是通过build({}).get_name();我们可以将这个东西彻底私有。

### 部件
上面的写法就是一种扩展部件的形式，我们可以在任意对象上调用build方法，来对这个对象进行新功能的封装，并且拥有者一些私有的方法。

## 数组
JS本身其实没有数组的数据结构，但是他有一个array-like的对象。与其他语言相比，他不要求里面的对象类型相同。和一般的对象相比，他多了能够使用序号访问属性的能力，而且还有一个无法遍历的属性length。

  length属性的值是数组的最大整数属性名加1。

将length的值设置小，超出的部分将会被截掉，设置大了，会填充undefined。

我们使用delete可以删除数组中的元素，但是会留下一个空洞undefined。

我们想要优雅的删除，可以使用slice，从某一个位置截到另一个位置，如果只有一个参数，就截到最后，如果是负数，就加上length后再看。或者使用比较强大的splice方法，一参为位置，2参为数量，后面的为想要添加的元素。

这几个函数每次操作都会移除原属性，重新插入，所以大型数组的效率不会太好。换种数据结构呗..链表不就完了

### 枚举
for in倒是可以遍历，但是无法保证属性的顺序，可能有些浏览器是按照顺序来的，但是我们没法保证。而且从原型继承来的属性问题依然存在，倒是可以Object.hasOwnProperty来判断，不过太麻烦了。一般就直接用for语句了。

### 判断array
我们可以typeof属性length看是不是number，然后propertyIsEnumerable来检测length是不是无法枚举。

或者Object.prototype.toString().apply(value) == '[object Array]'来判断。
