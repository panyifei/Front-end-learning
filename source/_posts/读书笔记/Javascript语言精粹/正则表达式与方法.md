---
layout: default
title: \{#\{ site.name \}#\}
---
# 正则表达式与方法
JS的正则借鉴的是Perl，通常正则表达式相较于等效的字符串处理有显著的`性能优势`。

## 看个例子
```javascript
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Z-a-z]+)(?::(\d))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
```

一块块的看，`(?:([A-Za-z]+):)?`，这里`?:`代表后面的分组并不捕获(还蛮推荐这么做的，因为捕获会有性能上的缺失)，最后的`?`代表是可选的，0次或者1次。`()`这个代表捕获组。

`(\/{0,3})`这个代表0个到3个`/`。

([0-9.\-A-Z-a-z]+)这个主要是里面的`.`字符，这个字符在外面代表着任意字符，在中括号里面代表着`.`。中括号里面好像就只有`-`需要进行转义。

其他的就比较正常了。

## 标识
  - g：全局，匹配多次，(不同的方法对这个的支持不同，exec代表着下次匹配的位置，search会忽略，match会返回所有的匹配结果..)
  - i：是否区分大小写
  - m：是否支持多行(^和$能匹配航结束符，使用了m之后，正则表达式就会匹配每行的开头和结尾了)

如果我们创建一个正则表达式时使用RegExp的写法的，注意`\`本身需要转义，也就是说我们使用他来转义时，需要使用两个。因为我是通过字符串的形式传入的，而字符串的\在正则和字符串中有特别的含义，所以这个符号我们需要进行转义。

## RegExp对象的属性

 - global：如果标识g被使用，值就是true
 - ignoreCase：如果是i被使用，值为true
 - lastIndex：下一次exec匹配的索引，初始值为0
 - multiline：标识m被使用，值为true
 - source：正则表达式的源码文本

## 正则表达式的一些元素

 - 分支：|，就是只要匹配任意一个条件，就会被匹配
 - 序列：就是包含一个或多个正则表达式因子，每个因子能选择是否跟随一个量词
 - 正则表达式因子：可以是一个字符，一个圆括号的组，一个字符类，或者一个转义序列
 - 转义：其实就是要背一下咯，\d(匹配一个数字),\w(匹配数字字母下划线),\s(空白符)，\1代表分组1所捕获的文本的引用，这个很好使
 - 分组
  - 捕获型：
    - 在圆括号中包住的就是一个捕获组，第一个就是分组1，第二个就是分组2
    - (?<name>exp)：这种写法就是指定了分组名为name了
  - 非捕获型：就是`(?:)`这个仅能做简单的匹配，但是不会捕获所匹配的文本
    - 向前正向匹配：`(?=)`也是非捕获的，即使匹配前面的部分
    - 向前负向匹配：`(?!)?`类似的，但是他是匹配失败才会继续向前进行匹配。
 - 字符集：`[]`就是一组字符的便利方式
 - 转义：就是想匹配特殊字符本身，我们需要加个\来做这件事情
 - 量词：`{}`就是这个因子要被匹配的次数，注意正则遵守贪婪匹配的原则

# 方法
## Array

 - array.concat():就是复制产生新数组，如果参数是数组，每一项会被单独的添加，并且是浅复制。两个对象如果更改的话会被同时更改。
 - array.join():这个比使用+号运算符的速度要慢，因为现代的浏览器，包括IE8以后的版本，都对+号连接字符串进行了特别的优化了。
 - array.pop():就是推出array的最后一个元素并且返回他。
 - array.push():这个和concat差不多，但是他会整个推入内容，并返回新长度。
 - array.reverse():这个会反转数组，并返回数组本身
 - array.shift();移除第一个元素并且返回他，比pop慢多了。
 - array.slice():就是切割数组，从起始位置到终点位置，只传一个值的话就截到最后，传负值的话就加上length
 - array.sort():默认就是当做字符串比较，也可以传入比较函数，如果返回的-1，则第一个参数排在前面
 - array.splice():1参位置，2参删除的个数，后面的都是添加的
 - array.unshift():就是从前部插入一个值。返回新长度

## Function
apply这个写的太多了

## Number

 - number.toExponential(小数点位数):就是转化为指数的形式，位数必须为0-20
 - number.toFixed(小数点位数):转化为十进制的字符串，这个值必须在0-20
 - number.toPrecision(整体的位数):转化为十进制的字符串，整体的位数必须为0-21
 - number.toString(几进制):这里控制是几进制显示

## Object
 - object.hasOwnProperty:判断这个属性是不是自带的

## RegExp
 - regexp.exec：最强大和最慢的方法，如果带有g，则查找不是从起始位置，而是lastIndex的位置开始。
 - regexp.test：最简单的和最快的方法，如果匹配，就返回true，注意g标识是没有用的

## String
 - string.charCodeAt:返回的是那个位置的字符码位，如果小于0或大于等于length，返回NaN，这个蛮奇怪的..
 - string.charAt
 - string.concat:这个不如用+号呢
 - string.indexOf

 方法很多，就不一个个写了


 # 代码风格以及特性

  - 优秀的程序拥有前瞻性的结构，预见了修改，又不会让其成为过度的负担
  - 清晰的表达方式

 主要就是良好的习惯，包括空格习惯，tab习惯等等，主要是能够规范编代码。

# 优秀特性

 - 函数是顶级对象，有词法作用域的闭包
 - 基于原型链继承的动态对象
 - 对象字面量和数组字面量
