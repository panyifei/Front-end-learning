---
layout: default
title: 正则表达式
---

[babel 在线运行地址](https://babeljs.io/repl/#?experimental=true&evaluate=true&loose=true&spec=true&code=)

##构造函数的修改
以前的构造函数只支持`字符串`

```javascript
var regex = new RegExp("xyz", "i");
var regex = /xyz/i;
```

现在的接受`正则表达式`作为参数，就是传入正则表达式的拷贝。

如果有第二个参数的话，则将会覆盖`原修饰符`，如果没有的话，则使用传入的表达式的修饰符。

```javascript
var regex = new RegExp(/xyz/gi, "g");
console.log(regex.flags); //g
```

##新的修饰符
###u 修饰符
`unicode模式`

用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。
ECMAscript 正则表达式支持就不够细致
一直的就不支持 4 个字节的 UTF-16

- '啊'的是\u554a，’啊’.length //1
- ‘𠮷’就是\ud842\udfb7，’𠮷’.length //2

```javascript
/^\uD83D/.test('\uD83D\uDC2A')
// true
/^\uD83D/u.test('\uD83D\uDC2A')
//false
//es5不支持4个字节的UTF-16，会将齐识别为两个字符
```

####.字符

- 正则里面是匹配除了换行符以外的任意字符。
- es5 不包括码点大于 0xFFFF 的 Unicode 字符，加上了 u 才能识别

```javascript
var s = "𠮷";
console.log(/^.$/.test(s)); //false
console.log(/^.$/u.test(s)); //true
```

不添加 u 字符的话，上面的字符串就会被当成两个字符从而匹配失败

    ‘𠮷’实际上就是这个\ud842\udfb7

####uincode 字符表示法

```javascript
/\u{61}/.test("a") / // false
//简单的61次u
a /
u.test("a") / // true
  //识别为u0061
  𠮷 /
  u.test("𠮷"); // true
//想写超过四位的只能这么表示
```

如果想使用这种大括号的形式来表示 unicode 字符

- 前面需要加上\u 之外
- 还需要加上 u 修饰符

####量词

```javascript
/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
/𠮷{2}/.test('𠮷𠮷') // false
//  /\ud842\udfb7{2}/.test('\ud842\udfb7\ud842\udfb7’);
/𠮷{2}/u.test('𠮷𠮷') // true
```

也就是下面的情况是可以的
console.log(/𠮷{2}/.test('\ud842\udfb7\udfb7')); //true

####预定义模式

/^\S$/.test('𠮷') // false
/^\S$/u.test('𠮷') // true

\S 能够识别非空白字符，然后通过 u 修饰符可以正确地将两位的 UTF-16 识别为一位，故而匹配了
与此相同的还有\D(非数字),\W

    \w在正则中可以识别`汉字`，但是ECMA的正则实现不全面，不能匹配汉字。

####i 修饰符
如果想识别非规范的字符，必须得加上 u

```javascript
/[a-z]/i.test("\u212A") / // false
  [a - z] /
  iu.test("\u212A"); // true
```

###y 修饰符
“粘连”（sticky）修饰符，表现与`g修饰符`很像，g 只要剩下的存在匹配就行，但是 y 要求必须从剩下的第一位开始匹配

    注意第一次也必须从lastindex匹配，也就是默认的0开始

```javascript
var s = "aaa_aa_a";
var r1 = /a+/g;
console.log(r1.exec(s));
console.log(r1.exec(s));
var r2 = /a+/y;
console.log(r2.exec(s));
console.log(r2.exec(s));
```

    babel，traceur几个转换器暂未支持，还是firefox给力

###sticky 属性
与 y 修饰符相匹配，这个表示是否设置了 y

###flags 属性
会返回正则表达式的修饰符
就和 source 属性会返回表达式的正文一样

```javascript
// 返回正则表达式的修饰符
/abc/gi.flags /
  // 'gi'
  abc /
  ig.sources;
//abc
```

###字符串的正则方法
字符串对象使用正则表达式的四个方法:
match，replace，search，split

ES6 在语言的内部改为了使用 RegExp 的实例方法

    所有与正则相关的方法，都定义到了RegExp对象上

###RegExp.escape
静态方法是来将字符串转义成正则模式的。
并没有成为 6 或者 7 的官方方法，只是有这个需求。

    就是将一些保留字符进行转义

参考自阮一峰的[ECMAScript6 入门](http://es6.ruanyifeng.com/#docs/regex)

todo： i 修饰符中有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B 与\u212A 都是大写的 K?
todo： 再细一点
todo： 文字编码
