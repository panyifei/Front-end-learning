---
layout: default
title: js高级程序设计-6章面向对象的程序设计
categories:
  - 读书笔记
  - js高级程序设计
---

重新看一次这一章..

对象就是无序属性的集合，属性包含基本值，对象和函数

## 创建简单对象

我们可以 new Object()或者通过对象自变量{}的形式来创建。

每个属性都有一些特性，包括

- Configurable:能够通过 delete 删除或者重新定义属性的特性
- Enumerable:能否通过 for in 循环返回属性
- Writable:是否可以修改属性的值
- Value：属性的数据值

一般这些特性都是 true 的，想要修改的话，我们只能使用`Object.defineProperty`来进行修改。

有种叫做访问器属性，只能通过 defineProperty 来进行定义，我们可以定义 get 和 set 方法，当然可以不全部指定。

我们还可以通过 defineProperties 来一次定义多个属性。

### 读取属性的特性

Object.getOwnPropertyDescriptor 可以得到想要的属性的特性。

## 创建特定形式的对象

### 工厂模式

最初是工厂模式的，就是简单的一个方法，每次 new Object()，然后添加属性，最后返回这个新的对象回去，但是问题来了，我们得不到创建出来的东西的类型，于是有了构造函数的模式

### 构造函数

我们使用构造函数来创建对象，每个对象都能访问到 contructor(构造函数)属性，该属性指向构造函数(注意这个 constructor 并不是实例本身拥有的，而是原型对象会有这个 constructor，然后属性查找找到了原型上的 contructor 而已！！！！！)。

只要创建了一个新函数，就会为该函数创建一个 prototype，指向该函数的原型对象。

原型对象会有一个 constructor，指向构造函数。

实例对象只拥有一个指针能指向原型对象，一般叫做**proto**，基本都是被隐藏的属性！！如果我们想要遍历原型链的话，可以通过 ES6 的 Object.getPrototypeOf 来拿，最后一层为 null。

所以

- 只有原型对象才会有 contructor！！其他的实例对象能够访问是因为查找了原型！！
- 只有函数才有 prototype！！！实例对象也拥有指针指向原型对象，就是**proto**！！！

我们一旦在实例上申明了属性覆盖了原型属性，除非我们使用`delete`，才能够访问到原型属性。

Object.getOwnPropertyDescriptor 只能得到自己对象上属性的描述符，想得到原型对象上的，只能直接在原型对象上调用这个方法。

想要判断属性是不是原型属性：`!Object.hasOwnProperty(name) && (name in object)`

注意 constructr 和**proto**规范上也是 enumerable 为 false 的，当时并不是所有的浏览器都是这么实现的

Object.keys 可以得到 for in 循环的所有属性，当然不包括 enumerable 为 false 的;而 Object.getOwnPropertyNames()可以得到所有的实例属性，包括不可枚举的，但是**proto**这种不开放的还是得不到。

高程 145 页是有问题的，他说实例是有 constructor 的，其实没有..

### 重写原型

一般情况下我们为原型赋予新的属性，得一次次的敲，也可以直接重新给原型对象赋一个新对象

但是问题是我们新建的对象没有 constructor 了，我们可以在对象里面手动设置为原构造函数。但是直接设置的话，enumerable 就是 true 了，所以我们可以用`Object.defineProperty`来创建。

我们哪怕在生成了之后再进行原型对象的属性赋予，也是可以的。毕竟就是一个指针嘛，但是如果重设成一个对象，那么原来的原型还是老的。新的原型就是新设置的。

注意原型对象的 this 也被绑定到了新对象！！就是输如果原型方法 return this，返回的是自身！！

### 原型模式的弊端

原型模式最大的弊端是在共享属性，如果属性是一个函数的话，还不会有什么问题，如果属性不是函数的话，可能会造成相互影响的问题，除非每次 new 的时候都比较小心一点。

所以基本上构造函数肯定是和原型模式一起使用的。

这里有个什么动态的原型模式，很无聊，就是在构造函数内部进行判断，然后初始化原型...

还有个什么寄生构造函数模式，乱七八糟的，就是用 return 一个新的对象来替代 new 出来的新对象，没啥价值...
